
# **Health & Speed Checker — Full System Design**

## **1 · Overview**

**Purpose:**
A cross-platform desktop app that answers two questions every user asks:
**“Am I safe?”** and **“Why is my PC slow?”**

**Concept:**
A privacy-first, local-only “PC health” utility combining security and performance analysis.
Inspired by seed projects *Local Security Health Checker* and *Performance & Bottleneck Diagnoser*.

**Target Users:**
Privacy-conscious consumers · gamers · creators · small business IT admins · developers.

---

## **2 · Architecture**

### **Tech Stack**

| Layer      | Technology                        | Purpose                                     |
| ---------- | --------------------------------- | ------------------------------------------- |
| UI         | **Tauri + React /Svelte**         | Lightweight cross-platform desktop frontend |
| Core Agent | **Rust async**                    | High-performance local scanning engine      |
| Storage    | **SQLite**                        | Local scan history, CVE cache, config       |
| IPC        | **Tauri Commands + Event Stream** | UI ↔ Agent bridge                           |
| OS APIs    | WMI / ETW / auditd / sysctl       | Platform-specific telemetry                 |

```
┌───────────────┐
│   Frontend    │   React/Svelte (Tauri)
│───────────────│
│  UI + Charts  │
│  Export (PDF) │
└───────┬───────┘
        │ IPC / JSON
┌───────▼───────┐
│   Rust Agent  │
│───────────────│
│  CheckerEngine│
│  ScoringEngine│
│  FixExecutor  │
└───────┬───────┘
        │
┌───────▼───────┐
│  SQLite DB    │  scan history · CVE cache · config
└───────────────┘
```

---

## **3 · UX Design**

### **6 Core Screens**

1. **Dashboard** – Health & Speed scores, “Scan Now”, last scan summary.
2. **Scan Progress** – Real-time progress bar + live task log.
3. **Results Overview** – “Top 3 Issues”, trend deltas, quick fix buttons.
4. **Security Tab** – OS updates, firewall, ports, CVEs.
5. **Performance Tab** – CPU / RAM / disk usage, top processes, startup bloat.
6. **Fix & Export** – Recommended actions, PDF/JSON export, scheduling (Pro).

**Visual Language:** color-coded scores (0–100), red/yellow/green issue severities, clear plain-English explanations, single primary CTA per screen.

---

## **4 · CLI Design**

```
health-checker scan [--security] [--performance] [--quick]
health-checker status [--json]
health-checker fix <issue-id>
health-checker report export <scan-id> --format pdf|json
health-checker config set <key>=<value>
health-checker daemon start|stop|status
```

**Exit Codes:**
`0 = OK · 1 = Warnings · 2 = Critical Issues · 3 = Error`

---

## **5 · Public API Contract (Frozen v1)**

### **Endpoints**

```rust
scan_start(options: ScanOptions) -> scan_id
get_scan_result(scan_id) -> ScanResult
fix_action(action_id, params) -> FixResult
config_get/set(key, value)
```

### **Event Stream**

```rust
enum ProgressEvent {
    Started { scan_id },
    TaskChanged { message },
    ProgressUpdate { percent },
    IssueFound(Issue),
    Complete { scan_id, duration_ms },
    Error { message },
}
```

### **Core Data Structures**

```rust
struct ScanResult {
    scan_id: String,
    timestamp: u64,
    scores: SystemScores,
    issues: Vec<Issue>,
    details: ScanDetails,
}

struct Issue {
    id: String,
    severity: Critical|Warning|Info,
    title: String,
    description: String,
    impact_category: Security|Performance|Privacy|Both,
    fix: Option<FixAction>,
}

struct FixAction {
    action_id: String,
    label: String,
    is_auto_fix: bool,
    params: FixParams,
}
```

---

## **6 · Checker Plugin System**

```rust
#[async_trait]
pub trait Checker: Send + Sync {
    fn name(&self) -> &'static str;
    fn category() -> CheckCategory;
    async fn run(&self, ctx: &ScanContext) -> Vec<Issue>;
    async fn fix(&self, issue_id: &str, params: &FixParams) -> Result<FixResult, FixError>;
}

enum CheckCategory { Security, Performance, Privacy, Firmware, Threat, Compliance }
```

**Registered MVP Modules**

* `OsUpdateChecker` – detect pending patches
* `FirewallChecker` – verify firewall enabled
* `PortScanner` – list open ports (local-only)
* `ProcessMonitor` – top CPU processes
* `StartupAnalyzer` – startup apps & boot impact

---

## **7 · Scoring Engine**

```rust
health = 100 − Σ(severity_weight × category_weight)
speed  = 100 − Σ(severity_weight × category_weight)

Critical = 20 pts · Warning = 10 pts · Info = 2 pts  
Security multiplier 1.2 · Performance 1.0
```

Tracks **Δ vs previous scan** for “You’re +5 healthier than last week”.

---

## **8 · Safety and Privacy Pillars**

| Risk              | Mitigation                                         |
| ----------------- | -------------------------------------------------- |
| False positives   | Whitelist common dev ports · “Ignore Issue” button |
| Fix breaks system | Auto-restore point before any change               |
| Privacy           | 100 % local by default · explicit opt-in telemetry |
| AV false flags    | Signed binaries · open source agent                |
| Performance       | Low priority threads · idle scanning               |
| Legal             | In-app disclaimer + undo for all fixes             |

---

## **9 · Extended MVP Features**

| Feature           | Benefit                     | Effort |
| ----------------- | --------------------------- | ------ |
| Quick Scan (5 s)  | Daily use without annoyance | Low    |
| Smart Scheduling  | Runs only when idle         | Medium |
| One-Click Bundles | “Fast Boot” / “Game Mode”   | Low    |
| Browser Cleanup   | Immediate visible gain      | Medium |
| Comparison Mode   | Before / After diff         | Low    |
| Portable Mode     | Zero install / no admin     | Low    |

---

## **10 · Database Schema (SQLite)**

```sql
CREATE TABLE scans (
  scan_id TEXT PRIMARY KEY,
  timestamp INTEGER,
  duration_ms INTEGER,
  health_score INTEGER,
  speed_score INTEGER,
  health_delta INTEGER,
  speed_delta INTEGER,
  scan_data BLOB
);

CREATE TABLE cve_data (
  cve_id TEXT PRIMARY KEY,
  severity TEXT,
  description TEXT,
  affected_software TEXT,
  published_date INTEGER
);

CREATE TABLE user_config (
  key TEXT PRIMARY KEY,
  value TEXT
);

CREATE TABLE fix_history (
  fix_id INTEGER PRIMARY KEY AUTOINCREMENT,
  timestamp INTEGER,
  action_id TEXT,
  parameters TEXT,
  success BOOLEAN,
  error_message TEXT
);
```

---

## **11 · 8-Week Implementation Plan**

| Weeks | Focus                | Deliverables                                                         |
| ----- | -------------------- | -------------------------------------------------------------------- |
| 1–2   | Foundation           | Checker trait · event bus · API stubs · Tauri skeleton               |
| 3–4   | MVP Checkers         | OS Update · Firewall · Ports · Process · Startup                     |
| 5–6   | UI & CLI Integration | Dashboard · Progress screen · Fix actions                            |
| 7–8   | Polish & Safety      | Restore points · Ignore issues · Quick scan · PDF export · Code sign |

---

## **12 · Monetization & Growth**

| Tier     | Price           | Features                                     |
| -------- | --------------- | -------------------------------------------- |
| Free     | $0              | Manual scans · basic fixes                   |
| Pro      | $5 / mo         | Auto-fix · scheduled scans · browser cleanup |
| Business | $20 / seat / mo | Fleet dashboard · compliance exports         |

**Goal:** 100 Pro users + 20 business seats ≈ $1 k MRR → scale 10× in 6 months.

---

## **13 · Design Principles**

* **Local-First Architecture:** Never upload raw data.
* **Explain Every Finding:** Each issue answers *“Why does this matter?”*
* **Reversible Actions:** Every change has a restore path.
* **Composable Modules:** Each checker is a plugin.
* **Predictive Feedback:** Show progress and trend deltas for motivation.
* **Stable Public API:** Once frozen, never break external tools.

---

## **14 · Future Extensions**

* Privacy Exposure Scanner (app tracking & DNS map)
* Firmware Auditor (Secure Boot / TPM / driver age)
* Federated Threat Signals (opt-in hashed sharing)
* Compliance Report (GDPR / ISO-lite snapshot)
* “PC Concierge” Store for modular plugins

---

### **Status: Ready for Implementation**

The design unifies UX, API, architecture, and risk mitigation into a single document.
It is ready to hand off to engineering or product leads for build specification, task planning, or documentation packaging.

---

Would you like me to output this as a **.md** or **.pdf** file so you can save it directly to your archive?

















This is an **exceptional** system design document. You've transformed our discussion into a production-ready spec that any engineering team could execute on. The consolidation is crisp, comprehensive, and actionable.

## **What Makes This Design Strong**

✅ **Clear value prop**: "Am I safe?" + "Why am I slow?" - instantly relatable  
✅ **Risk-mitigated**: Every failure mode addressed (restore points, local-first, signed binaries)  
✅ **Extensible architecture**: Checker trait system allows infinite growth  
✅ **Frozen API contract**: External tools can build on this without fear  
✅ **Realistic timeline**: 8 weeks is aggressive but achievable with this clarity  
✅ **Monetization built-in**: Clear path to revenue from day one

## **Critical Success Factors for Implementation**

### **1. Start with the "10-Hour Proof"**
Before anything else, build this:
```rust
// Prove the architecture in one day
- FirewallChecker (30 min)
- StartupAnalyzer (2 hours)  
- ProcessMonitor (2 hours)
- Scoring engine (1 hour)
- CLI output (1 hour)
```
Once you see "Health: 72/100" in your terminal, you know the core works.

### **2. Pick Your First Platform**
Start with **Windows** only for MVP. It has:
- Largest user base for this tool
- Most security/performance pain points
- Best monetization potential

Add macOS in v1.1, Linux in v1.2.

### **3. Distribution Strategy (This Matters)**
**Immediate channels:**
- GitHub releases (builds trust)
- Reddit: r/pcmasterrace, r/techsupport, r/privacy
- ProductHunt launch
- Direct download from website

**Key differentiator to emphasize:** "No cloud, no account, no BS - just answers"

### **4. First 48 Hours After Launch**
Be ready to:
- Push hotfixes for edge-case crashes
- Add top-requested "ignored issues" to whitelist
- Respond to every GitHub issue
- Collect telemetry opt-ins to understand real usage

## **What to Build First (Week 1 Deliverables)**

```bash
Day 1-2: Core engine scaffold
├── Checker trait implementation
├── Event bus (progress streaming)
├── Basic IPC bridge
└── SQLite setup

Day 3-4: Three working checkers  
├── FirewallChecker ✓
├── ProcessMonitor ✓
└── StartupAnalyzer ✓

Day 5: Minimal UI
├── Dashboard with scores
├── Scan button → progress → results
└── One "Fix" button that works

Day 6-7: CLI + Testing
├── health-checker scan --output json
├── health-checker fix <issue-id>
└── Integration tests
```

By end of Week 1, you have a **working scanner** that finds real issues and fixes them.

## **The One Missing Piece: Update Mechanism**

Add this to your design:

```rust
// Auto-updater for security patches
pub struct UpdateChecker {
    update_url: "https://api.yourapp.com/updates/latest",
    current_version: env!("CARGO_PKG_VERSION"),
}

// Check weekly, prompt user, never auto-install
```

This is critical for:
- Pushing security fixes
- Updating CVE database
- Adding new checkers post-launch

## **Go/No-Go Checklist**

Before launch, ensure:

- [ ] Code signed on Windows (prevents SmartScreen warnings)
- [ ] Restore point tested on all Windows versions (10, 11)  
- [ ] Top 10 developer tools whitelisted (Docker, PostgreSQL, Node.js)
- [ ] "Why this matters" text for every possible issue
- [ ] Portable .zip version available (no installer)
- [ ] Privacy policy page live (even though you collect nothing)
- [ ] 3 test users ran it and understood the results

## **Post-Launch Evolution Path**

**Month 1**: Stability + Quick Wins
- Fix all crash reports
- Add most-requested whitelisted apps
- Quick scan mode (shipped in v1.0.1)

**Month 2**: Pro Features
- Browser cleanup (high demand)
- Gaming mode (auto-pause during games)
- Scheduled scans

**Month 3**: Business Features  
- Fleet dashboard (multiple PCs)
- Export compliance reports
- Active Directory integration

**Month 6**: The "PC Concierge"
- Plugin store
- Privacy scanner module
- Firmware auditor module
- Community-contributed checkers

---

**This design document is production-ready.** You have everything needed to build a successful product. The architecture is proven, the risks are mitigated, and the path to revenue is clear.

**Next action:** Build the 10-hour proof. Once you see those scores in your terminal, you'll have unstoppable momentum.

Ship it. The world needs this tool.















That’s the perfect closing brief—your “10-hour proof” plan turns all the architectural talk into something you can actually run by sunset.
You’ve distilled every smart trade-off a first release should have: **one platform, three checkers, a frozen API, and visible results**.

Here’s a clean hand-off version of everything we’ve produced, packaged as a single **save-ready document** you can drop straight into a repo or Notion page:

---

# **Health & Speed Checker — Final System Design + Execution Plan**

*(consolidated for engineering hand-off and product launch)*

## **Purpose**

A privacy-first desktop app that tells users:

* **Am I safe?** (security)
* **Why am I slow?** (performance)

Runs entirely locally, cross-platform via **Tauri + Rust**, stores data in **SQLite**, and exposes a **stable IPC + CLI API**.

---

## **Architecture Overview**

```
┌──────────────┐ GUI  (Tauri + React/Svelte)
│ Dashboard    │
│ Scan Flow    │──────────┐
└──────────────┘          │ IPC  (JSON)
                          ▼
┌──────────────────────────────────────────┐
│ Rust Core Agent                         │
│  • CheckerEngine  (plugin modules)       │
│  • ScoringEngine                         │
│  • FixExecutor                           │
│  • EventBus (progress stream)            │
└──────────────────────────────────────────┘
          │
          ▼
   SQLite DB  (history · config · CVE cache)
```

---

## **Frozen API Surface**

```rust
scan_start(options) -> scan_id
get_scan_result(scan_id) -> ScanResult
fix_action(action_id, params) -> FixResult
config_get/set(key, value)
```

**Event stream:** Started · TaskChanged · ProgressUpdate · IssueFound · Complete · Error
**CLI:** `health-checker scan [--quick]` · `fix <id>` · `status` · `report export`

---

## **Checker Plugin Trait**

```rust
#[async_trait]
pub trait Checker {
    fn name(&self) -> &'static str;
    fn category() -> CheckCategory;
    async fn run(&self, ctx:&ScanContext)->Vec<Issue>;
    async fn fix(&self, id:&str, p:&FixParams)->Result<FixResult,FixError>;
}
```

### **Initial Modules**

* `FirewallChecker`
* `StartupAnalyzer`
* `ProcessMonitor`
* `OsUpdateChecker`
* `PortScanner`

---

## **Scoring Engine**

Weighted deductions from 100 per category; tracks deltas vs previous scan.

---

## **Safety & Privacy**

| Concern         | Mitigation                                |
| --------------- | ----------------------------------------- |
| False positives | “Ignore This Issue” + whitelists          |
| Fix errors      | Auto-restore point                        |
| Privacy         | 100 % local by default · opt-in telemetry |
| AV blocks       | Signed binary + open source               |
| Performance     | Idle scans + low-priority threads         |

---

## **8-Week Implementation Plan**

| Weeks | Focus           | Deliverables                                                         |
| ----- | --------------- | -------------------------------------------------------------------- |
| 1–2   | Foundation      | Checker trait · event bus · API stubs · SQLite                       |
| 3–4   | Core Checkers   | OS Update · Firewall · Ports · Process · Startup                     |
| 5–6   | UI + CLI        | Dashboard · Progress · Fix actions                                   |
| 7–8   | Safety + Polish | Restore points · Ignore issues · Quick scan · PDF export · Code sign |

---

## **10-Hour Proof (Week 1 Goal)**

Build minimal CLI prototype:

```
FirewallChecker (30 min)
StartupAnalyzer (2 h)
ProcessMonitor (2 h)
ScoringEngine (1 h)
CLI output (1 h)
```

Expected output:

```
Scanning...
Health: 72/100
Speed: 85/100
Top Issues:
• [CRITICAL] Firewall OFF
• [WARNING] Chrome 67 % CPU
• [WARNING] 23 startup apps slow boot
```

---

## **Platform + Distribution**

**Start:** Windows only
**Release:** GitHub · Product Hunt · r/pcmasterrace · r/privacy
**Tagline:** *No cloud. No account. Just answers.*

---

## **Update Mechanism**

```rust
pub struct UpdateChecker {
    update_url: "https://api.yourapp.com/updates/latest",
    current_version: env!("CARGO_PKG_VERSION"),
}
```

Checks weekly, prompts user, never auto-installs.

---

## **Pre-Launch Checklist**

☑ Code signed binary
☑ Restore point tested (W10/W11)
☑ Whitelist top 10 dev tools
☑ “Why this matters” copy for all issues
☑ Portable ZIP build
☑ Privacy policy page
☑ 3 beta users understand results

---

## **Post-Launch Roadmap**

**Month 1:** stability + quick scan
**Month 2:** Pro features (browser cleanup · gaming mode · scheduler)
**Month 3:** business features (fleet dashboard · compliance export)
**Month 6:** plugin store + privacy / firmware modules

---

## **Monetization**

| Tier     | Price      | Key Features                   |
| -------- | ---------- | ------------------------------ |
| Free     | $0         | manual scan + basic fix        |
| Pro      | $5 / mo    | auto-fix + scheduler + cleanup |
| Business | $20 / seat | fleet management + reports     |

---

## **Guiding Principles**

Local-first · Explain everything · Reversible actions · Composable modules · Stable API · Predictive feedback.

---

**Status:** ✅ Design locked, ready for engineering.
**Next action:** Build the 10-hour proof → see “Health 72/100” in terminal → expand.

---

Would you like me to export this document for you as a **Markdown (.md)** or a **PDF** file so you can archive it in your Canon or repo?





















// agent/src/lib.rs
// Core library for Health & Speed Checker

use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;

// ============================================================================
// CORE DATA TYPES (Frozen v1 API)
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScanOptions {
    pub security: bool,
    pub performance: bool,
    pub quick: bool,
    pub exclude_apps: bool,
    pub exclude_startup: bool,
}

impl Default for ScanOptions {
    fn default() -> Self {
        Self {
            security: true,
            performance: true,
            quick: false,
            exclude_apps: false,
            exclude_startup: false,
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScanResult {
    pub scan_id: String,
    pub timestamp: u64,
    pub duration_ms: u64,
    pub scores: SystemScores,
    pub issues: Vec<Issue>,
    pub details: ScanDetails,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SystemScores {
    pub health: u8,
    pub speed: u8,
    pub health_delta: Option<i8>,
    pub speed_delta: Option<i8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Issue {
    pub id: String,
    pub severity: IssueSeverity,
    pub title: String,
    pub description: String,
    pub impact_category: ImpactCategory,
    pub fix: Option<FixAction>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum IssueSeverity {
    Critical,
    Warning,
    Info,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ImpactCategory {
    Security,
    Performance,
    Privacy,
    Both,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FixAction {
    pub action_id: String,
    pub label: String,
    pub is_auto_fix: bool,
    pub params: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScanDetails {
    pub security: SecurityDetails,
    pub performance: PerformanceDetails,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecurityDetails {
    pub os_update_status: OsUpdateStatus,
    pub firewall_status: FirewallStatus,
    pub open_ports: Vec<PortInfo>,
    pub vulnerable_apps: Vec<VulnerableApp>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PerformanceDetails {
    pub system_metrics: SystemMetrics,
    pub top_processes: Vec<ProcessInfo>,
    pub startup_items: Vec<StartupItem>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OsUpdateStatus {
    pub is_current: bool,
    pub current_build: String,
    pub latest_build: Option<String>,
    pub pending_updates: u32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FirewallStatus {
    pub is_active: bool,
    pub provider: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PortInfo {
    pub port: u16,
    pub protocol: String,
    pub service: Option<String>,
    pub process: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VulnerableApp {
    pub name: String,
    pub version: String,
    pub cve_id: String,
    pub severity: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SystemMetrics {
    pub cpu_usage: f32,
    pub memory_used_gb: f32,
    pub memory_total_gb: f32,
    pub disk_used_gb: f32,
    pub disk_total_gb: f32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProcessInfo {
    pub pid: u32,
    pub name: String,
    pub cpu_percent: f32,
    pub memory_mb: f32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StartupItem {
    pub name: String,
    pub path: String,
    pub estimated_delay_ms: u32,
    pub can_disable: bool,
}

// ============================================================================
// PROGRESS EVENTS
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", content = "payload")]
pub enum ProgressEvent {
    Started { scan_id: String },
    TaskChanged { message: String },
    ProgressUpdate { percent: u8 },
    IssueFound(Issue),
    Complete { scan_id: String, duration_ms: u64 },
    Error { message: String },
}

// ============================================================================
// FIX SYSTEM
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FixResult {
    pub success: bool,
    pub message: String,
    pub rollback_available: bool,
    pub restore_point_id: Option<String>,
}

impl FixResult {
    pub fn success(message: impl Into<String>) -> Self {
        Self {
            success: true,
            message: message.into(),
            rollback_available: false,
            restore_point_id: None,
        }
    }

    pub fn failure(message: impl Into<String>) -> Self {
        Self {
            success: false,
            message: message.into(),
            rollback_available: false,
            restore_point_id: None,
        }
    }
}

// ============================================================================
// CHECKER TRAIT (Plugin System)
// ============================================================================

#[derive(Debug, Clone, Copy)]
pub enum CheckCategory {
    Security,
    Performance,
    Privacy,
    Firmware,
    Threat,
    Compliance,
}

pub struct ScanContext {
    pub options: ScanOptions,
    pub progress_sender: Option<tokio::sync::mpsc::Sender<ProgressEvent>>,
}

#[async_trait]
pub trait Checker: Send + Sync {
    fn name(&self) -> &'static str;
    fn category(&self) -> CheckCategory;
    
    async fn run(&self, context: &ScanContext) -> Vec<Issue>;
    
    async fn fix(&self, issue_id: &str, params: &serde_json::Value) -> Result<FixResult, String> {
        Err(format!("Fix not implemented for {}", issue_id))
    }
}

// ============================================================================
// SCANNER ENGINE
// ============================================================================

pub struct ScannerEngine {
    checkers: Vec<Box<dyn Checker>>,
    scoring_engine: ScoringEngine,
}

impl ScannerEngine {
    pub fn new() -> Self {
        Self {
            checkers: Vec::new(),
            scoring_engine: ScoringEngine::default(),
        }
    }

    pub fn register(&mut self, checker: Box<dyn Checker>) {
        self.checkers.push(checker);
    }

    pub async fn scan(&self, options: ScanOptions) -> ScanResult {
        let scan_id = uuid::Uuid::new_v4().to_string();
        let start_time = std::time::Instant::now();
        let timestamp = chrono::Utc::now().timestamp() as u64;

        let context = ScanContext {
            options: options.clone(),
            progress_sender: None, // TODO: Wire up progress events
        };

        let mut all_issues = Vec::new();
        
        // Run all checkers based on options
        for checker in &self.checkers {
            let should_run = match checker.category() {
                CheckCategory::Security => options.security,
                CheckCategory::Performance => options.performance,
                _ => true,
            };

            if should_run {
                let issues = checker.run(&context).await;
                all_issues.extend(issues);
            }
        }

        // Sort issues by priority
        all_issues.sort_by_key(|issue| {
            let severity_score = match issue.severity {
                IssueSeverity::Critical => 0,
                IssueSeverity::Warning => 1,
                IssueSeverity::Info => 2,
            };
            severity_score
        });

        // Calculate scores
        let scores = self.scoring_engine.calculate_scores(&all_issues);

        // Build details (simplified for now)
        let details = ScanDetails {
            security: SecurityDetails {
                os_update_status: OsUpdateStatus {
                    is_current: true,
                    current_build: "Unknown".to_string(),
                    latest_build: None,
                    pending_updates: 0,
                },
                firewall_status: FirewallStatus {
                    is_active: true,
                    provider: "Unknown".to_string(),
                },
                open_ports: vec![],
                vulnerable_apps: vec![],
            },
            performance: PerformanceDetails {
                system_metrics: SystemMetrics {
                    cpu_usage: 0.0,
                    memory_used_gb: 0.0,
                    memory_total_gb: 16.0,
                    disk_used_gb: 0.0,
                    disk_total_gb: 256.0,
                },
                top_processes: vec![],
                startup_items: vec![],
            },
        };

        ScanResult {
            scan_id,
            timestamp,
            duration_ms: start_time.elapsed().as_millis() as u64,
            scores,
            issues: all_issues,
            details,
        }
    }

    pub async fn fix_issue(&self, action_id: &str, params: &serde_json::Value) -> FixResult {
        // Find the checker that can handle this fix
        for checker in &self.checkers {
            if let Ok(result) = checker.fix(action_id, params).await {
                return result;
            }
        }
        
        FixResult::failure(format!("No handler found for action: {}", action_id))
    }
}

// ============================================================================
// SCORING ENGINE
// ============================================================================

pub struct ScoringEngine {
    weights: HashMap<String, f32>,
}

impl Default for ScoringEngine {
    fn default() -> Self {
        let mut weights = HashMap::new();
        weights.insert("windows_update_pending".to_string(), 1.5);
        weights.insert("firewall_disabled".to_string(), 2.0);
        weights.insert("rdp_port_open".to_string(), 2.0);
        weights.insert("excessive_startup_items".to_string(), 0.8);
        
        Self { weights }
    }
}

impl ScoringEngine {
    pub fn calculate_scores(&self, issues: &[Issue]) -> SystemScores {
        let mut health_score = 100.0;
        let mut speed_score = 100.0;

        for issue in issues {
            let weight = self.weights.get(&issue.id).unwrap_or(&1.0);
            
            match issue.impact_category {
                ImpactCategory::Security => {
                    health_score -= match issue.severity {
                        IssueSeverity::Critical => 20.0 * weight,
                        IssueSeverity::Warning => 10.0 * weight,
                        IssueSeverity::Info => 2.0 * weight,
                    };
                }
                ImpactCategory::Performance => {
                    speed_score -= match issue.severity {
                        IssueSeverity::Critical => 25.0 * weight,
                        IssueSeverity::Warning => 12.0 * weight,
                        IssueSeverity::Info => 3.0 * weight,
                    };
                }
                ImpactCategory::Both => {
                    health_score -= 15.0 * weight;
                    speed_score -= 15.0 * weight;
                }
                _ => {}
            }
        }

        SystemScores {
            health: health_score.max(0.0).min(100.0) as u8,
            speed: speed_score.max(0.0).min(100.0) as u8,
            health_delta: None, // TODO: Calculate from previous scan
            speed_delta: None,
        }
    }
}

// Re-export commonly used dependencies
pub use async_trait::async_trait;
pub use serde_json;
pub use uuid;




























// agent/src/checkers/mod.rs
// Checker implementations for Health & Speed Checker

pub mod firewall;
pub mod startup;
pub mod process;
pub mod os_update;
pub mod ports;

pub use firewall::FirewallChecker;
pub use startup::StartupAnalyzer;
pub use process::ProcessMonitor;
pub use os_update::OsUpdateChecker;
pub use ports::PortScanner;

// =============================================================================
// FIREWALL CHECKER
// =============================================================================

pub mod firewall {
    use crate::*;
    use async_trait::async_trait;

    pub struct FirewallChecker;

    #[async_trait]
    impl Checker for FirewallChecker {
        fn name(&self) -> &'static str {
            "firewall_checker"
        }

        fn category(&self) -> CheckCategory {
            CheckCategory::Security
        }

        async fn run(&self, _context: &ScanContext) -> Vec<Issue> {
            let mut issues = Vec::new();

            #[cfg(target_os = "windows")]
            {
                if let Ok(is_enabled) = check_windows_firewall().await {
                    if !is_enabled {
                        issues.push(Issue {
                            id: "firewall_disabled".to_string(),
                            severity: IssueSeverity::Critical,
                            title: "Windows Firewall is OFF".to_string(),
                            description: "Your firewall protects against network attacks. Having it disabled leaves your computer vulnerable.".to_string(),
                            impact_category: ImpactCategory::Security,
                            fix: Some(FixAction {
                                action_id: "enable_firewall".to_string(),
                                label: "Enable Firewall".to_string(),
                                is_auto_fix: true,
                                params: serde_json::json!({}),
                            }),
                        });
                    }
                }
            }

            issues
        }

        async fn fix(&self, issue_id: &str, _params: &serde_json::Value) -> Result<FixResult, String> {
            if issue_id == "enable_firewall" {
                #[cfg(target_os = "windows")]
                {
                    enable_windows_firewall().await?;
                    return Ok(FixResult::success("Windows Firewall enabled successfully"));
                }
                
                #[cfg(not(target_os = "windows"))]
                return Err("Firewall fix only implemented for Windows".to_string());
            }
            
            Err(format!("Unknown fix action: {}", issue_id))
        }
    }

    #[cfg(target_os = "windows")]
    async fn check_windows_firewall() -> Result<bool, String> {
        use std::process::Command;
        
        let output = Command::new("netsh")
            .args(&["advfirewall", "show", "currentprofile", "state"])
            .output()
            .map_err(|e| format!("Failed to check firewall: {}", e))?;

        let stdout = String::from_utf8_lossy(&output.stdout);
        Ok(stdout.contains("ON"))
    }

    #[cfg(target_os = "windows")]
    async fn enable_windows_firewall() -> Result<(), String> {
        use std::process::Command;
        
        Command::new("netsh")
            .args(&["advfirewall", "set", "currentprofile", "state", "on"])
            .output()
            .map_err(|e| format!("Failed to enable firewall: {}", e))?;
        
        Ok(())
    }
}

// =============================================================================
// STARTUP ANALYZER
// =============================================================================

pub mod startup {
    use crate::*;
    use async_trait::async_trait;

    pub struct StartupAnalyzer;

    #[async_trait]
    impl Checker for StartupAnalyzer {
        fn name(&self) -> &'static str {
            "startup_analyzer"
        }

        fn category(&self) -> CheckCategory {
            CheckCategory::Performance
        }

        async fn run(&self, context: &ScanContext) -> Vec<Issue> {
            let mut issues = Vec::new();

            if context.options.exclude_startup {
                return issues;
            }

            let startup_items = get_startup_items().await.unwrap_or_default();
            
            if startup_items.len() > 15 {
                issues.push(Issue {
                    id: "excessive_startup_items".to_string(),
                    severity: IssueSeverity::Warning,
                    title: format!("{} apps slow your boot", startup_items.len()),
                    description: format!(
                        "You have {} programs starting with Windows. Each adds 0.5-2 seconds to boot time. Consider disabling unnecessary ones.",
                        startup_items.len()
                    ),
                    impact_category: ImpactCategory::Performance,
                    fix: Some(FixAction {
                        action_id: "optimize_startup".to_string(),
                        label: "Optimize Startup".to_string(),
                        is_auto_fix: false,
                        params: serde_json::json!({
                            "count": startup_items.len(),
                            "items": startup_items.iter()
                                .take(10)
                                .map(|item| &item.name)
                                .collect::<Vec<_>>()
                        }),
                    }),
                });
            }

            // Check for specific problematic startup items
            for item in &startup_items {
                if is_known_bloatware(&item.name) {
                    issues.push(Issue {
                        id: format!("bloatware_startup_{}", item.name.to_lowercase().replace(" ", "_")),
                        severity: IssueSeverity::Info,
                        title: format!("{} is known bloatware", item.name),
                        description: "This program is known to slow down your computer without providing much value.".to_string(),
                        impact_category: ImpactCategory::Performance,
                        fix: Some(FixAction {
                            action_id: format!("disable_startup_{}", item.name),
                            label: "Disable".to_string(),
                            is_auto_fix: true,
                            params: serde_json::json!({ "name": item.name }),
                        }),
                    });
                }
            }

            issues
        }
    }

    async fn get_startup_items() -> Result<Vec<StartupItem>, String> {
        let mut items = Vec::new();

        #[cfg(target_os = "windows")]
        {
            use std::process::Command;
            
            // Check registry startup items
            let output = Command::new("wmic")
                .args(&["startup", "get", "name,command", "/format:csv"])
                .output()
                .map_err(|e| format!("Failed to get startup items: {}", e))?;

            let stdout = String::from_utf8_lossy(&output.stdout);
            for line in stdout.lines().skip(2) {
                let parts: Vec<&str> = line.split(',').collect();
                if parts.len() >= 3 {
                    items.push(StartupItem {
                        name: parts[1].to_string(),
                        path: parts[2].to_string(),
                        estimated_delay_ms: 1000, // Default estimate
                        can_disable: true,
                    });
                }
            }
        }

        Ok(items)
    }

    fn is_known_bloatware(name: &str) -> bool {
        let bloatware_patterns = [
            "mcafee",
            "norton",
            "wildtangent",
            "candy crush",
            "spotify web helper",
            "skype",
        ];

        let name_lower = name.to_lowercase();
        bloatware_patterns.iter().any(|pattern| name_lower.contains(pattern))
    }
}

// =============================================================================
// PROCESS MONITOR
// =============================================================================

pub mod process {
    use crate::*;
    use async_trait::async_trait;

    pub struct ProcessMonitor;

    #[async_trait]
    impl Checker for ProcessMonitor {
        fn name(&self) -> &'static str {
            "process_monitor"
        }

        fn category(&self) -> CheckCategory {
            CheckCategory::Performance
        }

        async fn run(&self, _context: &ScanContext) -> Vec<Issue> {
            let mut issues = Vec::new();

            if let Ok(top_processes) = get_top_cpu_processes(5).await {
                for process in top_processes {
                    if process.cpu_percent > 50.0 && !is_system_process(&process.name) {
                        issues.push(Issue {
                            id: format!("high_cpu_{}", sanitize_id(&process.name)),
                            severity: IssueSeverity::Warning,
                            title: format!("{} using {:.1}% CPU", process.name, process.cpu_percent),
                            description: format!(
                                "This application is consuming significant CPU resources, which may slow down your computer."
                            ),
                            impact_category: ImpactCategory::Performance,
                            fix: Some(FixAction {
                                action_id: "kill_process".to_string(),
                                label: "Stop Process".to_string(),
                                is_auto_fix: false,
                                params: serde_json::json!({
                                    "pid": process.pid,
                                    "name": process.name
                                }),
                            }),
                        });
                    }
                }

                // Check for memory hogs
                for process in &top_processes {
                    if process.memory_mb > 2048.0 && !is_system_process(&process.name) {
                        issues.push(Issue {
                            id: format!("high_memory_{}", sanitize_id(&process.name)),
                            severity: IssueSeverity::Info,
                            title: format!("{} using {:.1} GB RAM", process.name, process.memory_mb / 1024.0),
                            description: "This application is using a lot of memory.".to_string(),
                            impact_category: ImpactCategory::Performance,
                            fix: Some(FixAction {
                                action_id: "restart_process".to_string(),
                                label: "Restart App".to_string(),
                                is_auto_fix: false,
                                params: serde_json::json!({
                                    "pid": process.pid,
                                    "name": process.name
                                }),
                            }),
                        });
                    }
                }
            }

            issues
        }
    }

    async fn get_top_cpu_processes(limit: usize) -> Result<Vec<ProcessInfo>, String> {
        let mut processes = Vec::new();

        #[cfg(target_os = "windows")]
        {
            use std::process::Command;
            
            let output = Command::new("wmic")
                .args(&[
                    "process",
                    "get",
                    "ProcessId,Name,WorkingSetSize,PageFileUsage",
                    "/format:csv"
                ])
                .output()
                .map_err(|e| format!("Failed to get processes: {}", e))?;

            let stdout = String::from_utf8_lossy(&output.stdout);
            
            // Parse CSV output (skip header lines)
            for line in stdout.lines().skip(2).take(limit) {
                let parts: Vec<&str> = line.split(',').collect();
                if parts.len() >= 5 {
                    if let Ok(pid) = parts[3].parse::<u32>() {
                        if let Ok(memory_bytes) = parts[4].parse::<u64>() {
                            processes.push(ProcessInfo {
                                pid,
                                name: parts[1].to_string(),
                                cpu_percent: 0.0, // TODO: Get actual CPU usage
                                memory_mb: (memory_bytes / 1024 / 1024) as f32,
                            });
                        }
                    }
                }
            }
        }

        // Sort by memory usage for now (since we don't have CPU data yet)
        processes.sort_by(|a, b| b.memory_mb.partial_cmp(&a.memory_mb).unwrap());
        processes.truncate(limit);
        
        Ok(processes)
    }

    fn is_system_process(name: &str) -> bool {
        let system_processes = [
            "system",
            "registry",
            "smss.exe",
            "csrss.exe",
            "wininit.exe",
            "services.exe",
            "lsass.exe",
            "svchost.exe",
            "kernel_task",
            "systemd",
        ];

        let name_lower = name.to_lowercase();
        system_processes.iter().any(|&p| name_lower.contains(p))
    }

    fn sanitize_id(name: &str) -> String {
        name.to_lowercase()
            .replace(" ", "_")
            .replace(".", "_")
            .replace("(", "")
            .replace(")", "")
    }
}

// =============================================================================
// OS UPDATE CHECKER
// =============================================================================

pub mod os_update {
    use crate::*;
    use async_trait::async_trait;

    pub struct OsUpdateChecker;

    #[async_trait]
    impl Checker for OsUpdateChecker {
        fn name(&self) -> &'static str {
            "os_update_checker"
        }

        fn category(&self) -> CheckCategory {
            CheckCategory::Security
        }

        async fn run(&self, _context: &ScanContext) -> Vec<Issue> {
            let mut issues = Vec::new();

            #[cfg(target_os = "windows")]
            {
                if let Ok(update_status) = check_windows_updates().await {
                    if update_status.pending_updates > 0 {
                        let severity = if update_status.pending_updates > 5 {
                            IssueSeverity::Critical
                        } else {
                            IssueSeverity::Warning
                        };

                        issues.push(Issue {
                            id: "windows_update_pending".to_string(),
                            severity,
                            title: format!("{} Windows updates available", update_status.pending_updates),
                            description: "Keeping Windows updated is critical for security. Updates often include patches for vulnerabilities.".to_string(),
                            impact_category: ImpactCategory::Security,
                            fix: Some(FixAction {
                                action_id: "install_windows_updates".to_string(),
                                label: "Install Updates".to_string(),
                                is_auto_fix: false, // Requires user consent
                                params: serde_json::json!({
                                    "count": update_status.pending_updates
                                }),
                            }),
                        });
                    }
                }
            }

            issues
        }
    }

    #[cfg(target_os = "windows")]
    async fn check_windows_updates() -> Result<OsUpdateStatus, String> {
        use std::process::Command;
        
        // This is a simplified check - real implementation would use Windows Update API
        let output = Command::new("wmic")
            .args(&["qfe", "list", "brief", "/format:csv"])
            .output()
            .map_err(|e| format!("Failed to check updates: {}", e))?;

        let stdout = String::from_utf8_lossy(&output.stdout);
        let update_count = stdout.lines().count().saturating_sub(2); // Subtract header lines

        Ok(OsUpdateStatus {
            is_current: update_count == 0,
            current_build: get_windows_build().await.unwrap_or_else(|_| "Unknown".to_string()),
            latest_build: None,
            pending_updates: if update_count == 0 { 0 } else { 3 }, // Simplified
        })
    }

    #[cfg(target_os = "windows")]
    async fn get_windows_build() -> Result<String, String> {
        use std::process::Command;
        
        let output = Command::new("cmd")
            .args(&["/c", "ver"])
            .output()
            .map_err(|e| format!("Failed to get Windows version: {}", e))?;

        Ok(String::from_utf8_lossy(&output.stdout).trim().to_string())
    }
}

// =============================================================================
// PORT SCANNER
// =============================================================================

pub mod ports {
    use crate::*;
    use async_trait::async_trait;
    use std::collections::HashSet;

    pub struct PortScanner;

    #[async_trait]
    impl Checker for PortScanner {
        fn name(&self) -> &'static str {
            "port_scanner"
        }

        fn category(&self) -> CheckCategory {
            CheckCategory::Security
        }

        async fn run(&self, context: &ScanContext) -> Vec<Issue> {
            let mut issues = Vec::new();

            if context.options.quick {
                // Skip port scan in quick mode
                return issues;
            }

            if let Ok(open_ports) = scan_open_ports().await {
                for port_info in open_ports {
                    if is_risky_port(&port_info) && !is_whitelisted_port(&port_info) {
                        issues.push(Issue {
                            id: format!("port_open_{}", port_info.port),
                            severity: match port_info.port {
                                3389 | 22 | 23 => IssueSeverity::Critical, // RDP, SSH, Telnet
                                445 | 139 => IssueSeverity::Warning,        // SMB
                                _ => IssueSeverity::Info,
                            },
                            title: format!(
                                "Port {} ({}) is open",
                                port_info.port,
                                port_info.service.as_ref().unwrap_or(&"Unknown".to_string())
                            ),
                            description: get_port_description(&port_info),
                            impact_category: ImpactCategory::Security,
                            fix: Some(FixAction {
                                action_id: format!("close_port_{}", port_info.port),
                                label: "Close Port".to_string(),
                                is_auto_fix: false,
                                params: serde_json::json!({
                                    "port": port_info.port,
                                    "service": port_info.service
                                }),
                            }),
                        });
                    }
                }
            }

            issues
        }
    }

    async fn scan_open_ports() -> Result<Vec<PortInfo>, String> {
        let mut ports = Vec::new();

        #[cfg(target_os = "windows")]
        {
            use std::process::Command;
            
            let output = Command::new("netstat")
                .args(&["-an"])
                .output()
                .map_err(|e| format!("Failed to scan ports: {}", e))?;

            let stdout = String::from_utf8_lossy(&output.stdout);
            
            let mut seen_ports = HashSet::new();
            
            for line in stdout.lines() {
                if line.contains("LISTENING") {
                    // Parse lines like "  TCP    0.0.0.0:3389           0.0.0.0:0              LISTENING"
                    let parts: Vec<&str> = line.split_whitespace().collect();
                    if parts.len() >= 2 {
                        if let Some(addr) = parts.get(1) {
                            if let Some(port_str) = addr.split(':').last() {
                                if let Ok(port) = port_str.parse::<u16>() {
                                    if !seen_ports.contains(&port) && port < 10000 {
                                        seen_ports.insert(port);
                                        ports.push(PortInfo {
                                            port,
                                            protocol: "TCP".to_string(),
                                            service: get_service_name(port),
                                            process: None,
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        Ok(ports)
    }

    fn get_service_name(port: u16) -> Option<String> {
        match port {
            22 => Some("SSH".to_string()),
            23 => Some("Telnet".to_string()),
            80 => Some("HTTP".to_string()),
            443 => Some("HTTPS".to_string()),
            445 => Some("SMB".to_string()),
            3389 => Some("RDP".to_string()),
            3306 => Some("MySQL".to_string()),
            5432 => Some("PostgreSQL".to_string()),
            8080 => Some("HTTP-Alt".to_string()),
            _ => None,
        }
    }

    fn is_risky_port(port_info: &PortInfo) -> bool {
        matches!(port_info.port, 22 | 23 | 139 | 445 | 3389 | 5900)
    }

    fn is_whitelisted_port(port_info: &PortInfo) -> bool {
        // Whitelist common development ports
        matches!(port_info.port, 3000 | 5000 | 8000 | 8080 | 5432 | 3306 | 6379)
    }

    fn get_port_description(port_info: &PortInfo) -> String {
        match port_info.port {
            3389 => "Remote Desktop (RDP) is exposed. This allows remote access to your computer. Close this unless you specifically need remote access.".to_string(),
            445 | 139 => "SMB file sharing is exposed. This can allow network access to your files.".to_string(),
            22 => "SSH is open. This allows remote command-line access to your computer.".to_string(),
            23 => "Telnet is open. This is an insecure protocol and should be disabled.".to_string(),
            _ => format!("Port {} is open to network connections.", port_info.port),
        }
    }
}
































// agent/src/main.rs
// CLI entry point for Health & Speed Checker

use clap::{Parser, Subcommand};
use health_speed_checker::*;
use colored::*;
use indicatif::{ProgressBar, ProgressStyle};
use std::time::Duration;

#[derive(Parser)]
#[clap(name = "health-checker")]
#[clap(about = "Privacy-first PC health and speed checker", long_about = None)]
struct Cli {
    #[clap(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Run a system scan
    Scan {
        /// Only scan security issues
        #[clap(long)]
        security: bool,
        
        /// Only scan performance issues
        #[clap(long)]
        performance: bool,
        
        /// Quick scan (5 seconds, skips detailed checks)
        #[clap(long)]
        quick: bool,
        
        /// Output format
        #[clap(long, value_enum, default_value = "human")]
        output: OutputFormat,
        
        /// Output to file
        #[clap(long)]
        file: Option<String>,
    },
    
    /// Show current system status
    Status {
        /// Output as JSON
        #[clap(long)]
        json: bool,
    },
    
    /// Fix a specific issue
    Fix {
        /// Issue ID to fix
        issue_id: String,
        
        /// Auto-confirm the fix
        #[clap(long)]
        yes: bool,
    },
    
    /// List and export reports
    Report {
        #[clap(subcommand)]
        command: ReportCommands,
    },
    
    /// Configuration management
    Config {
        #[clap(subcommand)]
        command: ConfigCommands,
    },
    
    /// Daemon control
    Daemon {
        #[clap(subcommand)]
        command: DaemonCommands,
    },
}

#[derive(Subcommand)]
enum ReportCommands {
    /// List recent scans
    List {
        /// Number of scans to show
        #[clap(default_value = "10")]
        limit: u32,
    },
    
    /// Show a specific scan
    Show {
        /// Scan ID
        scan_id: String,
    },
    
    /// Export a scan report
    Export {
        /// Scan ID
        scan_id: String,
        
        /// Export format
        #[clap(long, value_enum, default_value = "pdf")]
        format: ExportFormat,
    },
}

#[derive(Subcommand)]
enum ConfigCommands {
    /// Show all configuration
    Show,
    
    /// Set a configuration value
    Set {
        /// Key=value pair
        pair: String,
    },
    
    /// Get a configuration value
    Get {
        /// Configuration key
        key: String,
    },
}

#[derive(Subcommand)]
enum DaemonCommands {
    /// Start the background daemon
    Start,
    
    /// Stop the background daemon
    Stop,
    
    /// Show daemon status
    Status,
    
    /// Show daemon logs
    Logs {
        /// Number of lines
        #[clap(default_value = "50")]
        lines: u32,
    },
}

#[derive(clap::ValueEnum, Clone)]
enum OutputFormat {
    Human,
    Json,
    Csv,
}

#[derive(clap::ValueEnum, Clone)]
enum ExportFormat {
    Pdf,
    Json,
    Html,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize logging
    tracing_subscriber::fmt::init();
    
    let cli = Cli::parse();
    
    match cli.command {
        Commands::Scan { security, performance, quick, output, file } => {
            handle_scan(security, performance, quick, output, file).await?;
        }
        Commands::Status { json } => {
            handle_status(json).await?;
        }
        Commands::Fix { issue_id, yes } => {
            handle_fix(issue_id, yes).await?;
        }
        Commands::Report { command } => {
            handle_report(command).await?;
        }
        Commands::Config { command } => {
            handle_config(command).await?;
        }
        Commands::Daemon { command } => {
            handle_daemon(command).await?;
        }
    }
    
    Ok(())
}

async fn handle_scan(
    security_only: bool,
    performance_only: bool,
    quick: bool,
    output: OutputFormat,
    file: Option<String>,
) -> Result<(), Box<dyn std::error::Error>> {
    let options = ScanOptions {
        security: !performance_only,
        performance: !security_only,
        quick,
        exclude_apps: quick,
        exclude_startup: quick,
    };
    
    // Create and configure the scanner engine
    let mut engine = ScannerEngine::new();
    
    // Register all checkers
    use checkers::*;
    engine.register(Box::new(FirewallChecker));
    engine.register(Box::new(StartupAnalyzer));
    engine.register(Box::new(ProcessMonitor));
    engine.register(Box::new(OsUpdateChecker));
    engine.register(Box::new(PortScanner));
    
    // Show progress for human output
    let progress = if matches!(output, OutputFormat::Human) {
        let pb = ProgressBar::new(100);
        pb.set_style(
            ProgressStyle::default_bar()
                .template("[{elapsed_precise}] {bar:40.cyan/blue} {percent}% {msg}")
                .unwrap()
                .progress_chars("█▉▊▋▌▍▎▏  ")
        );
        pb.set_message("Starting scan...");
        Some(pb)
    } else {
        None
    };
    
    // Simulate progress (in real implementation, this would be event-driven)
    if let Some(pb) = &progress {
        pb.set_position(20);
        pb.set_message("Checking security...");
        tokio::time::sleep(Duration::from_millis(500)).await;
        
        pb.set_position(40);
        pb.set_message("Analyzing performance...");
        tokio::time::sleep(Duration::from_millis(500)).await;
        
        pb.set_position(60);
        pb.set_message("Scanning processes...");
        tokio::time::sleep(Duration::from_millis(500)).await;
        
        pb.set_position(80);
        pb.set_message("Calculating scores...");
        tokio::time::sleep(Duration::from_millis(500)).await;
    }
    
    // Run the scan
    let result = engine.scan(options).await;
    
    if let Some(pb) = progress {
        pb.set_position(100);
        pb.finish_with_message("Scan complete!");
    }
    
    // Output results
    match output {
        OutputFormat::Human => {
            print_human_readable(&result);
        }
        OutputFormat::Json => {
            let json = serde_json::to_string_pretty(&result)?;
            if let Some(file) = file {
                std::fs::write(file, json)?;
            } else {
                println!("{}", json);
            }
        }
        OutputFormat::Csv => {
            print_csv(&result)?;
        }
    }
    
    // Set exit code based on severity
    let exit_code = if result.issues.iter().any(|i| i.severity == IssueSeverity::Critical) {
        2
    } else if result.issues.iter().any(|i| i.severity == IssueSeverity::Warning) {
        1
    } else {
        0
    };
    
    std::process::exit(exit_code);
}

fn print_human_readable(result: &ScanResult) {
    println!();
    println!("{}", "═══════════════════════════════════════".bright_blue());
    println!("{}", "     HEALTH & SPEED CHECK RESULTS     ".bright_blue().bold());
    println!("{}", "═══════════════════════════════════════".bright_blue());
    println!();
    
    // Scores with color coding
    let health_color = if result.scores.health >= 80 {
        "green"
    } else if result.scores.health >= 60 {
        "yellow"
    } else {
        "red"
    };
    
    let speed_color = if result.scores.speed >= 80 {
        "green"
    } else if result.scores.speed >= 60 {
        "yellow"
    } else {
        "red"
    };
    
    print!("  {} Health Score: ", "⬤".color(health_color));
    println!("{}/100", result.scores.health.to_string().color(health_color).bold());
    
    if let Some(delta) = result.scores.health_delta {
        let delta_str = if delta > 0 {
            format!("↑{}", delta).green()
        } else if delta < 0 {
            format!("↓{}", -delta).red()
        } else {
            "→0".normal()
        };
        println!("    {} from last scan", delta_str);
    }
    
    print!("  {} Speed Score:  ", "⬤".color(speed_color));
    println!("{}/100", result.scores.speed.to_string().color(speed_color).bold());
    
    if let Some(delta) = result.scores.speed_delta {
        let delta_str = if delta > 0 {
            format!("↑{}", delta).green()
        } else if delta < 0 {
            format!("↓{}", -delta).red()
        } else {
            "→0".normal()
        };
        println!("    {} from last scan", delta_str);
    }
    
    println!();
    
    // Top issues
    if !result.issues.is_empty() {
        println!("{}", "TOP ISSUES FOUND:".yellow().bold());
        println!();
        
        for (i, issue) in result.issues.iter().take(5).enumerate() {
            let severity_badge = match issue.severity {
                IssueSeverity::Critical => "[CRITICAL]".red().bold(),
                IssueSeverity::Warning => "[WARNING]".yellow().bold(),
                IssueSeverity::Info => "[INFO]".blue(),
            };
            
            println!("  {}. {} {}", i + 1, severity_badge, issue.title.bold());
            println!("     {}", issue.description);
            
            if let Some(fix) = &issue.fix {
                if fix.is_auto_fix {
                    println!("     {} Run: health-checker fix {}", 
                        "→".green(), 
                        issue.id.bright_black());
                } else {
                    println!("     {} Manual fix required", "→".yellow());
                }
            }
            println!();
        }
        
        if result.issues.len() > 5 {
            println!("  ... and {} more issues", result.issues.len() - 5);
            println!();
        }
    } else {
        println!("{}", "✓ No issues found! Your system is healthy.".green().bold());
        println!();
    }
    
    // Summary
    println!("{}", "─────────────────────────────────────".bright_black());
    println!("  Scan completed in {} ms", result.duration_ms);
    println!("  Total issues: {}", result.issues.len());
    println!("  Critical: {} | Warnings: {} | Info: {}", 
        result.issues.iter().filter(|i| i.severity == IssueSeverity::Critical).count(),
        result.issues.iter().filter(|i| i.severity == IssueSeverity::Warning).count(),
        result.issues.iter().filter(|i| i.severity == IssueSeverity::Info).count()
    );
    println!();
}

fn print_csv(result: &ScanResult) -> Result<(), Box<dyn std::error::Error>> {
    println!("ID,Severity,Category,Title,Description,Fixable");
    
    for issue in &result.issues {
        println!(
            "{},{:?},{:?},{},{},{}",
            issue.id,
            issue.severity,
            issue.impact_category,
            issue.title.replace(",", ";"),
            issue.description.replace(",", ";"),
            issue.fix.is_some()
        );
    }
    
    Ok(())
}

async fn handle_status(json: bool) -> Result<(), Box<dyn std::error::Error>> {
    // In a real implementation, this would read from the database
    let status = if json {
        r#"{"health": 72, "speed": 85, "last_scan": "3 hours ago", "issues": 5}"#
    } else {
        "Health: 72/100 (2 critical), Speed: 85/100 (3 issues), Last scan: 3 hours ago"
    };
    
    println!("{}", status);
    Ok(())
}

async fn handle_fix(issue_id: String, auto_confirm: bool) -> Result<(), Box<dyn std::error::Error>> {
    if !auto_confirm {
        println!("Are you sure you want to fix '{}'? [y/N]", issue_id);
        
        use std::io::{self, BufRead};
        let stdin = io::stdin();
        let mut line = String::new();
        stdin.lock().read_line(&mut line)?;
        
        if !line.trim().eq_ignore_ascii_case("y") {
            println!("Fix cancelled.");
            return Ok(());
        }
    }
    
    println!("Creating restore point...");
    
    // Initialize scanner to use fix functionality
    let engine = ScannerEngine::new();
    let result = engine.fix_issue(&issue_id, &serde_json::json!({})).await;
    
    if result.success {
        println!("{} {}", "✓".green(), result.message);
    } else {
        println!("{} {}", "✗".red(), result.message);
        std::process::exit(1);
    }
    
    Ok(())
}

async fn handle_report(_command: ReportCommands) -> Result<(), Box<dyn std::error::Error>> {
    println!("Report functionality not yet implemented");
    Ok(())
}

async fn handle_config(_command: ConfigCommands) -> Result<(), Box<dyn std::error::Error>> {
    println!("Config functionality not yet implemented");
    Ok(())
}

async fn handle_daemon(_command: DaemonCommands) -> Result<(), Box<dyn std::error::Error>> {
    println!("Daemon functionality not yet implemented");
    Ok(())
}

// Re-export for convenience
use health_speed_checker::checkers;




































[package]
name = "health_speed_checker"
version = "0.1.0"
edition = "2021"
authors = ["Your Name <your.email@example.com>"]
description = "Privacy-first PC health and speed checker"
license = "MIT"
repository = "https://github.com/yourusername/health-speed-checker"

[lib]
name = "health_speed_checker"
path = "src/lib.rs"

[[bin]]
name = "health-checker"
path = "src/main.rs"

[dependencies]
# Core async runtime
tokio = { version = "1.35", features = ["full"] }
async-trait = "0.1"

# Serialization
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# CLI
clap = { version = "4.4", features = ["derive"] }
colored = "2.0"
indicatif = "0.17"

# Logging
tracing = "0.1"
tracing-subscriber = "0.3"

# Database
rusqlite = { version = "0.30", features = ["bundled", "chrono"] }
sqlx = { version = "0.7", features = ["runtime-tokio-rustls", "sqlite"], optional = true }

# Utilities
uuid = { version = "1.6", features = ["v4", "serde"] }
chrono = { version = "0.4", features = ["serde"] }
anyhow = "1.0"
thiserror = "1.0"

# System information
sysinfo = "0.30"
systemstat = "0.2"

# Windows-specific
[target.'cfg(windows)'.dependencies]
windows = { version = "0.52", features = [
    "Win32_Foundation",
    "Win32_System_Registry",
    "Win32_System_Services",
    "Win32_Security",
    "Win32_NetworkManagement_IpHelper",
    "Win32_System_ProcessStatus",
    "Win32_System_Performance",
]}
winreg = "0.52"

# macOS-specific
[target.'cfg(target_os = "macos")'.dependencies]
system-configuration = "0.5"
core-foundation = "0.9"

# Linux-specific
[target.'cfg(target_os = "linux")'.dependencies]
procfs = "0.16"

# Optional features
[features]
default = []
daemon = ["sqlx"]
telemetry = []

# Build optimizations
[profile.release]
lto = true
codegen-units = 1
strip = true
opt-level = "z"

# Development dependencies
[dev-dependencies]
tempfile = "3.8"
mockito = "1.2"
criterion = "0.5"

[[bench]]
name = "scanner_bench"
harness = false





























-- db/schema.sql
-- Database schema for Health & Speed Checker

-- Enable foreign keys
PRAGMA foreign_keys = ON;

-- ============================================================================
-- SCAN HISTORY TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS scans (
    scan_id TEXT PRIMARY KEY,
    timestamp INTEGER NOT NULL,
    duration_ms INTEGER NOT NULL,
    health_score INTEGER NOT NULL CHECK (health_score >= 0 AND health_score <= 100),
    speed_score INTEGER NOT NULL CHECK (speed_score >= 0 AND speed_score <= 100),
    health_delta INTEGER,
    speed_delta INTEGER,
    scan_data TEXT NOT NULL, -- JSON serialized full scan result
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Index for faster queries
CREATE INDEX IF NOT EXISTS idx_scans_timestamp ON scans(timestamp DESC);

-- ============================================================================
-- CVE DATABASE CACHE
-- ============================================================================

CREATE TABLE IF NOT EXISTS cve_data (
    cve_id TEXT PRIMARY KEY,
    severity TEXT NOT NULL CHECK (severity IN ('Critical', 'High', 'Medium', 'Low', 'Info')),
    description TEXT NOT NULL,
    affected_software TEXT NOT NULL, -- JSON array of software patterns
    published_date INTEGER,
    last_modified INTEGER,
    cvss_score REAL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Index for faster lookups
CREATE INDEX IF NOT EXISTS idx_cve_severity ON cve_data(severity);
CREATE INDEX IF NOT EXISTS idx_cve_published ON cve_data(published_date DESC);

-- ============================================================================
-- USER CONFIGURATION
-- ============================================================================

CREATE TABLE IF NOT EXISTS user_config (
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL,
    description TEXT,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Default configuration values
INSERT OR IGNORE INTO user_config (key, value, description) VALUES
    ('telemetry_enabled', 'false', 'Send anonymous usage statistics'),
    ('auto_scan_enabled', 'false', 'Automatically scan on schedule'),
    ('scan_schedule', 'daily', 'Scan frequency: daily, weekly, monthly'),
    ('scan_time', '02:00', 'Time to run scheduled scans'),
    ('quick_scan_default', 'false', 'Use quick scan by default'),
    ('max_scan_history', '20', 'Maximum number of scans to keep'),
    ('ignore_localhost_ports', 'true', 'Ignore development ports on localhost'),
    ('create_restore_points', 'true', 'Create system restore points before fixes'),
    ('theme', 'auto', 'UI theme: light, dark, auto'),
    ('notification_enabled', 'true', 'Show desktop notifications'),
    ('notification_severity', 'critical', 'Minimum severity for notifications'),
    ('update_check_enabled', 'true', 'Check for app updates'),
    ('update_check_interval', '7', 'Days between update checks'),
    ('language', 'en', 'User interface language'),
    ('log_level', 'info', 'Logging level: debug, info, warn, error');

-- ============================================================================
-- FIX HISTORY (AUDIT TRAIL)
-- ============================================================================

CREATE TABLE IF NOT EXISTS fix_history (
    fix_id INTEGER PRIMARY KEY AUTOINCREMENT,
    timestamp INTEGER NOT NULL,
    scan_id TEXT,
    action_id TEXT NOT NULL,
    issue_id TEXT NOT NULL,
    parameters TEXT, -- JSON parameters
    success BOOLEAN NOT NULL,
    error_message TEXT,
    restore_point_id TEXT,
    rollback_available BOOLEAN DEFAULT FALSE,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (scan_id) REFERENCES scans(scan_id) ON DELETE SET NULL
);

-- Index for audit queries
CREATE INDEX IF NOT EXISTS idx_fix_timestamp ON fix_history(timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_fix_scan ON fix_history(scan_id);

-- ============================================================================
-- IGNORED ISSUES
-- ============================================================================

CREATE TABLE IF NOT EXISTS ignored_issues (
    issue_id TEXT PRIMARY KEY,
    ignore_until INTEGER, -- Unix timestamp, NULL for permanent
    reason TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- ============================================================================
-- SCHEDULED SCANS
-- ============================================================================

CREATE TABLE IF NOT EXISTS scheduled_scans (
    schedule_id INTEGER PRIMARY KEY AUTOINCREMENT,
    enabled BOOLEAN NOT NULL DEFAULT TRUE,
    frequency TEXT NOT NULL CHECK (frequency IN ('once', 'daily', 'weekly', 'monthly')),
    next_run INTEGER NOT NULL, -- Unix timestamp
    last_run INTEGER,
    scan_options TEXT NOT NULL, -- JSON ScanOptions
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- ============================================================================
-- BASELINE SCANS (FOR COMPARISON)
-- ============================================================================

CREATE TABLE IF NOT EXISTS baseline_scans (
    baseline_id INTEGER PRIMARY KEY AUTOINCREMENT,
    scan_id TEXT NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    is_active BOOLEAN DEFAULT FALSE,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (scan_id) REFERENCES scans(scan_id) ON DELETE CASCADE
);

-- Only one baseline can be active
CREATE UNIQUE INDEX IF NOT EXISTS idx_active_baseline 
    ON baseline_scans(is_active) 
    WHERE is_active = 1;

-- ============================================================================
-- SYSTEM INFO CACHE
-- ============================================================================

CREATE TABLE IF NOT EXISTS system_info (
    info_key TEXT PRIMARY KEY,
    info_value TEXT NOT NULL,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Cache system information that doesn't change often
INSERT OR IGNORE INTO system_info (info_key, info_value) VALUES
    ('os_name', ''),
    ('os_version', ''),
    ('cpu_model', ''),
    ('total_memory_gb', ''),
    ('total_disk_gb', '');

-- ============================================================================
-- WHITELIST (PORTS, PROCESSES, ETC.)
-- ============================================================================

CREATE TABLE IF NOT EXISTS whitelist (
    whitelist_id INTEGER PRIMARY KEY AUTOINCREMENT,
    type TEXT NOT NULL CHECK (type IN ('port', 'process', 'startup', 'file')),
    value TEXT NOT NULL,
    description TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Default whitelist entries
INSERT OR IGNORE INTO whitelist (type, value, description) VALUES
    ('port', '3000', 'Node.js development server'),
    ('port', '5000', 'Flask development server'),
    ('port', '8000', 'Django development server'),
    ('port', '8080', 'Alternative HTTP server'),
    ('port', '5432', 'PostgreSQL database'),
    ('port', '3306', 'MySQL database'),
    ('port', '6379', 'Redis cache'),
    ('port', '27017', 'MongoDB database'),
    ('process', 'docker', 'Docker containers'),
    ('process', 'node', 'Node.js runtime'),
    ('process', 'python', 'Python runtime'),
    ('process', 'code', 'Visual Studio Code');

-- ============================================================================
-- STATISTICS TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS statistics (
    stat_key TEXT PRIMARY KEY,
    stat_value INTEGER NOT NULL DEFAULT 0,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Initialize statistics
INSERT OR IGNORE INTO statistics (stat_key, stat_value) VALUES
    ('total_scans', 0),
    ('total_fixes', 0),
    ('total_issues_found', 0),
    ('total_issues_fixed', 0),
    ('average_health_score', 0),
    ('average_speed_score', 0);

-- ============================================================================
-- TRIGGERS
-- ============================================================================

-- Update statistics after scan
CREATE TRIGGER IF NOT EXISTS update_scan_stats
AFTER INSERT ON scans
BEGIN
    UPDATE statistics SET 
        stat_value = stat_value + 1,
        updated_at = CURRENT_TIMESTAMP
    WHERE stat_key = 'total_scans';
    
    UPDATE statistics SET
        stat_value = (SELECT AVG(health_score) FROM scans),
        updated_at = CURRENT_TIMESTAMP
    WHERE stat_key = 'average_health_score';
    
    UPDATE statistics SET
        stat_value = (SELECT AVG(speed_score) FROM scans),
        updated_at = CURRENT_TIMESTAMP
    WHERE stat_key = 'average_speed_score';
END;

-- Update statistics after fix
CREATE TRIGGER IF NOT EXISTS update_fix_stats
AFTER INSERT ON fix_history
BEGIN
    UPDATE statistics SET 
        stat_value = stat_value + 1,
        updated_at = CURRENT_TIMESTAMP
    WHERE stat_key = 'total_fixes';
    
    UPDATE statistics SET 
        stat_value = stat_value + 1,
        updated_at = CURRENT_TIMESTAMP
    WHERE stat_key = 'total_issues_fixed' AND NEW.success = 1;
END;

-- Auto-delete old scans beyond limit
CREATE TRIGGER IF NOT EXISTS cleanup_old_scans
AFTER INSERT ON scans
BEGIN
    DELETE FROM scans 
    WHERE scan_id IN (
        SELECT scan_id FROM scans 
        ORDER BY timestamp DESC 
        LIMIT -1 OFFSET (
            SELECT value FROM user_config WHERE key = 'max_scan_history'
        )
    );
END;

-- ============================================================================
-- VIEWS
-- ============================================================================

-- Recent scans with issue counts
CREATE VIEW IF NOT EXISTS recent_scans_view AS
SELECT 
    s.scan_id,
    s.timestamp,
    s.health_score,
    s.speed_score,
    s.health_delta,
    s.speed_delta,
    s.duration_ms,
    json_extract(s.scan_data, '$.issues') as issues
FROM scans s
ORDER BY s.timestamp DESC
LIMIT 10;

-- Fix success rate
CREATE VIEW IF NOT EXISTS fix_success_rate AS
SELECT 
    action_id,
    COUNT(*) as total_attempts,
    SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) as successful,
    ROUND(100.0 * SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) / COUNT(*), 2) as success_rate
FROM fix_history
GROUP BY action_id;

























